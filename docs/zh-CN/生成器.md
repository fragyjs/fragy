# 生成器

本文将详细阐述 Fragy 框架下的生成器是什么，该如何编写一个适用于 Fragy 的生成器。

## 执行流程

现阶段 Fragy 的生成流程如下：

![生成流程](https://raw.githubusercontent.com/fragyjs/fragy/main/docs/zh-CN/assets/generate-flow.svg)

主题可以在框架默认的生成器前后介入执行流程，执行特定的生成器。

所有生成器会被读入到队列，并按取出顺序进行执行。为了提升效率，生成器支持“同步”和“平行”两种执行方式。

在整个生成流程中，任意一个任务执行失败或抛出错误都将直接中断整个流程。

### 同步执行

同步执行即按照队列的取出顺序，在上一个生成器执行完成后开始执行。

在这一模式下我们视单一的生成器为一个任务。

### 平行执行

当框架发现队内列的一个任务是由生成器组成的队列，那么框架会同步执行该队列下的所有生成器。

我们使用 `Promise.all` 执行这些生成器，这意味着一旦其中有一个执行失败，整个生成流程都将中断。

在这一模式下我们视平行执行的所有生成器为一个任务，在所有生成器执行完成后，下一个任务才会被执行。

## 编写参考

生成器的本质是一个 `function`，其具体行为完全由开发者自行编写。

生成器应当接受一个参数用于访问生成器环境内的上下文，以下是一个最小范例：

```ts
const generator = (ctx: GeneratorContext) => {};
```

（对于非箭头函数，您也可以通过 `this` 访问上下文）

在 `GeneratorContext` 中，你可以访问到我们封装好的 `logger`，所有生成器共用的 `cache` 以及所有生成器共用的 `bus`。

### cache

`cache` 的本质是一个 `object`，我们封装了类似 Key-Value 存储的方法，具体定义如下所示：

```ts
interface GeneratorCache {
  get(key: string) => unknown;
  set(key: string, value: unknown) => void;
  remove(key: string) => void;
}
```

项目统一约定经过 `parseArticle` 解析过的文章数据统一用 `parsed-article_{filePath}` 作为 Key 存入缓存。

### bus

`bus` 的本质是 Node.js 的 EventEmitter，如果您想让您的生成器在框架生成的某些阶段执行，您可以在 `before` 内添加您的生成器，并利用 `bus` 控制生成器的执行时机。

项目统一约定事件名称为 `生成器名/事件名`。

您目前可以监听的事件如下：

```text
generateList/pathCheckFailed // generateList 路径检查失败
generateList/postCollectFailed // generateList 文章文件收集失败
generateList/postCollected // generateList 文章文件收集成功，在这之后您可以通过 cache 使用 post-files 这个 key 拿到文件列表，避免重复收集
```

### logger

我们建议您使用 `logger` 打印日志，而不是直接使用 `console` 或 `stdout`。

我们已基于 `chalk` 做了一些封装，使日志的变得更加友好。
