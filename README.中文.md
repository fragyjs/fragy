# Fragy

Fragy 是一个用 Vue 编写的、在客户端做动态渲染的轻量化博客框架。

## 使用方法

### 建站

使用 `npm@7` 全局安装 `fragy-cli`:

```bash
npm install fragy-cli -g
```

在这之后，使用 `fragy-cli` 执行初始化指令，开始一个 Fragy 项目:

```bash
fragy init
```

你需要根据工具的指示输入必要的信息，之后工具会自动完成整个初始化步骤。

在项目初始化完成后，你便可以使用以下命令创建一篇文章:

```bash
fragy create post
```

你可以在项目根目录下的 `.fragy/posts` 中找到创建的文章，已经写好的文章请直接放入这个文件夹内。

Fragy 基本兼容 Hexo 的文章格式，你可以基本无痛将之前在 Hexo 内编写的文章迁移到 Fragy。

在你完成了所有的工作后，你可以使用 `fragy build` 命令构建站点，你可以在根目录下的 `dist` 文件夹内找到生成产物，生成产物可以直接部署到某个静态文件托管平台或是某个 Web 服务器中。

在本地，你可以使用 `fragy serve` 命令启动一个本地服务器，在构建和部署前预览你的站点。

#### GitHub 模式

在 `v0.2.0` 版本后，Fragy 支持全新的元数据生成模式 —— `GitHub 模式`。

这一模式将不再要求你每次在更新、添加、删除文章后重新生成元数据，以刷新站点的文章目录，你只需要将你的文章简单地推送到 GitHub 仓库内即可。

在这一模式下，Fragy 会自动通过 GitHub 提供的 API 拉取你的文章信息与文章内容，并对文章进行即时的解析，获得元数据。

如果你期望使用这种模式，你需要注意以下几点规则和限制：

1. 首先你必须通过 `fragy setup github` 初始化位于 `fragy.config.js` 内的相关设置项，或者你可以手动编辑配置文件修改相关设置。

2. 如果你存放文章的目录不在 `.fragy/posts` 下，你需要手动指定 `base` 属性至仓库内你存放文章的目录。

3. 存放文章的目录结构必须是扁平的，如果有嵌套子文件夹，子文件夹内的文章将不会被检索到。

4. 如果你的站点主要面向国内用户，你可能需要配置一个代理服务器，该服务器可能会接收到 URL 类似于 `https://proxyserver.com/https%3A%2F%2Fapi.github.com%2Frepos%2Ffragyjs%2Ffragy%2Fcontents%2Fsrc` 的请求。

## 主题开发

详见[主题开发指南](https://github.com/fragyjs/fragy/blob/main/docs/zh-CN/%E4%B8%BB%E9%A2%98%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97.md)

## Q&A

**Q: 为什么不使用 SSG 或 SSR？**

A: 一些搜索引擎（如 Google）已经对 SPA 有足够良好的支持，客户端渲染在性能与 SEO 效果在我们看来是可以接受的，我们期望避开服务端渲染以尽可能干掉编译，同时降低主题的开发门槛。

基于客户端渲染，我们可以做到只生成少量的元数据，甚至不生成元数据，这使得即使我们完全使用 JavaScript，Fragy 的性能目前也是可以接受的。这也有利于未来我们进一步降低 Fragy 的部署与使用门槛。

**Q: 为什么不直接渲染好 Markdown，而是客户端进行渲染？**

A: 在 Fragy 的设计中，我们将`敏捷`排在了`性能`的前面。我们希望在用户修改了某个 Markdown 文件后，即使用户不做任何的编译操作，页面也能立刻体现 Markdown 的更改。在这种设计下，结合上一条问题，我们只能把解析与渲染 Markdown 的任务交给客户端。

**Q: 为什么不给主题开发者提供一些公共组件？**

A: 你可能注意到了，我们的主题开发采用了一个非常奔放的设计，框架只提供了非常基础的一部分内容，绝大部分能力都需要主题去实现。

这一切都基于我们希望`给开发者一个足够自由的开发体验`的想法，提供公共组件意味着自由度的降低，我们并不期望通过这种方式去束缚主题的开发者，毕竟目前连解析 Markdown 也有各种各样的解决方案，我们需要允许开发者自由选择他们需要的依赖、自由配置所需的依赖。

这种设计也允许社区内更有能力的开发者开发能力非常强大的主题，从长远来看这有利于 Fragy 生态的发展。

**Q: 为什么不使用 Vue 3 和 Vite？**

A: 项目的技术选型确定后，我们的初期开发阶段经历了一段长期的停滞，导致我们的技术选型略有一些落后。对于 Vite，我们不愿意付出踩坑成本，且 Vite 现阶段的生态有待发展。现阶段而言 Vue 3 + Webpack 对我们来说是最好的选择。

由于项目现有代码均是基于 Vue 2，迁移到 Vue 3 需要付出不少额外的时间成本，从目前项目的情况来看我们暂时不会进行迁移。

**Q: 为什么不使用 TypeScript？**

A: 我们并不认为在这个项目使用 TypeScript 是有利于开发的，且框架层的 API 很少，项目规模上来看，我们也没有使用 TypeScript 的必要性。从 API 层面来说，我们实际上并不限制主题开发者使用什么开发语言与 CSS 预处理器，毕竟 TypeScript、Sass、Stylus 的编译产物必然是 JavaScript 或 CSS，开发者只需要在编译阶段对主题代码加一层处理即可。

需要注意的是，我们默认只支持 JavaScript + Less。

## License

MIT
